#!/usr/bin/env python3
"""
Teste de Valida√ß√£o Completa do Sistema CWB Hub Hybrid AI
Executa testes abrangentes com diferentes tipos de solicita√ß√µes
"""

import asyncio
import logging
import time
from typing import List, Dict, Any

# Configurar logging para os testes
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

class SystemValidator:
    """Validador completo do sistema CWB Hub"""
    
    def __init__(self):
        self.test_results = []
        self.orchestrator = None
        
    async def initialize_system(self):
        """Inicializa o sistema para testes"""
        try:
            from src.core.hybrid_ai_orchestrator import HybridAIOrchestrator
            
            print("üîß Inicializando sistema CWB Hub...")
            self.orchestrator = HybridAIOrchestrator()
            await self.orchestrator.initialize_agents()
            
            print("‚úÖ Sistema inicializado com sucesso!")
            print(f"üë• Agentes ativos: {len(self.orchestrator.get_active_agents())}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro na inicializa√ß√£o: {e}")
            return False
    
    async def test_strategic_request(self):
        """Testa solicita√ß√£o estrat√©gica (CTO focus)"""
        print("\n" + "="*60)
        print("üéØ TESTE 1: Solicita√ß√£o Estrat√©gica")
        print("="*60)
        
        request = """
        Nossa empresa precisa definir a estrat√©gia tecnol√≥gica para os pr√≥ximos 3 anos.
        Queremos focar em inova√ß√£o, escalabilidade e competitividade no mercado.
        Como devemos proceder considerando tend√™ncias de IA, cloud computing e 
        transforma√ß√£o digital?
        """
        
        start_time = time.time()
        try:
            response = await self.orchestrator.process_request(request.strip())
            end_time = time.time()
            
            # Valida√ß√µes
            assert response is not None, "Resposta n√£o pode ser None"
            assert len(response) > 100, "Resposta muito curta"
            assert "CTO" in response or "estrat√©gia" in response.lower(), "Deve mencionar estrat√©gia"
            
            print(f"‚úÖ Teste estrat√©gico passou!")
            print(f"‚è±Ô∏è Tempo de resposta: {end_time - start_time:.2f}s")
            print(f"üìù Tamanho da resposta: {len(response)} caracteres")
            
            self.test_results.append({
                "test": "Strategic Request",
                "status": "PASS",
                "time": end_time - start_time,
                "response_length": len(response)
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Teste estrat√©gico falhou: {e}")
            self.test_results.append({
                "test": "Strategic Request", 
                "status": "FAIL",
                "error": str(e)
            })
            return False
    
    async def test_technical_request(self):
        """Testa solicita√ß√£o t√©cnica (Arquiteto + Full Stack focus)"""
        print("\n" + "="*60)
        print("üèóÔ∏è TESTE 2: Solicita√ß√£o T√©cnica")
        print("="*60)
        
        request = """
        Preciso desenvolver uma API REST para um sistema de e-commerce que suporte:
        - Autentica√ß√£o JWT
        - Cat√°logo de produtos com busca
        - Carrinho de compras
        - Processamento de pagamentos
        - Notifica√ß√µes em tempo real
        
        A API deve ser escal√°vel, segura e ter alta performance.
        """
        
        start_time = time.time()
        try:
            response = await self.orchestrator.process_request(request.strip())
            end_time = time.time()
            
            # Valida√ß√µes
            assert response is not None, "Resposta n√£o pode ser None"
            assert len(response) > 200, "Resposta muito curta para solicita√ß√£o t√©cnica"
            assert any(word in response.lower() for word in ["api", "arquitetura", "implementa√ß√£o"]), "Deve mencionar aspectos t√©cnicos"
            
            print(f"‚úÖ Teste t√©cnico passou!")
            print(f"‚è±Ô∏è Tempo de resposta: {end_time - start_time:.2f}s")
            print(f"üìù Tamanho da resposta: {len(response)} caracteres")
            
            self.test_results.append({
                "test": "Technical Request",
                "status": "PASS", 
                "time": end_time - start_time,
                "response_length": len(response)
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Teste t√©cnico falhou: {e}")
            self.test_results.append({
                "test": "Technical Request",
                "status": "FAIL",
                "error": str(e)
            })
            return False
    
    async def test_mobile_design_request(self):
        """Testa solicita√ß√£o mobile + design (Mobile + UX/UI focus)"""
        print("\n" + "="*60)
        print("üì± TESTE 3: Solicita√ß√£o Mobile + Design")
        print("="*60)
        
        request = """
        Quero criar um aplicativo mobile para delivery de comida com:
        - Interface intuitiva e atrativa
        - Experi√™ncia de usu√°rio excepcional
        - Funcionalidade offline
        - Geolocaliza√ß√£o
        - Pagamento integrado
        - Push notifications
        
        O app deve funcionar bem em iOS e Android.
        """
        
        start_time = time.time()
        try:
            response = await self.orchestrator.process_request(request.strip())
            end_time = time.time()
            
            # Valida√ß√µes
            assert response is not None, "Resposta n√£o pode ser None"
            assert len(response) > 150, "Resposta muito curta"
            assert any(word in response.lower() for word in ["mobile", "ux", "ui", "design", "usu√°rio"]), "Deve mencionar aspectos mobile/design"
            
            print(f"‚úÖ Teste mobile+design passou!")
            print(f"‚è±Ô∏è Tempo de resposta: {end_time - start_time:.2f}s")
            print(f"üìù Tamanho da resposta: {len(response)} caracteres")
            
            self.test_results.append({
                "test": "Mobile + Design Request",
                "status": "PASS",
                "time": end_time - start_time,
                "response_length": len(response)
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Teste mobile+design falhou: {e}")
            self.test_results.append({
                "test": "Mobile + Design Request",
                "status": "FAIL", 
                "error": str(e)
            })
            return False
    
    async def test_devops_quality_request(self):
        """Testa solicita√ß√£o DevOps + QA (DevOps + QA focus)"""
        print("\n" + "="*60)
        print("üîß TESTE 4: Solicita√ß√£o DevOps + Qualidade")
        print("="*60)
        
        request = """
        Preciso configurar um pipeline de CI/CD completo para nossa aplica√ß√£o web:
        - Testes automatizados
        - Deploy automatizado
        - Monitoramento de qualidade
        - Infraestrutura como c√≥digo
        - Seguran√ßa integrada
        - Rollback autom√°tico
        
        Tudo deve rodar na AWS com alta disponibilidade.
        """
        
        start_time = time.time()
        try:
            response = await self.orchestrator.process_request(request.strip())
            end_time = time.time()
            
            # Valida√ß√µes
            assert response is not None, "Resposta n√£o pode ser None"
            assert len(response) > 150, "Resposta muito curta"
            assert any(word in response.lower() for word in ["devops", "ci/cd", "testes", "qualidade", "infraestrutura"]), "Deve mencionar aspectos DevOps/QA"
            
            print(f"‚úÖ Teste DevOps+QA passou!")
            print(f"‚è±Ô∏è Tempo de resposta: {end_time - start_time:.2f}s")
            print(f"üìù Tamanho da resposta: {len(response)} caracteres")
            
            self.test_results.append({
                "test": "DevOps + QA Request",
                "status": "PASS",
                "time": end_time - start_time,
                "response_length": len(response)
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Teste DevOps+QA falhou: {e}")
            self.test_results.append({
                "test": "DevOps + QA Request",
                "status": "FAIL",
                "error": str(e)
            })
            return False
    
    async def test_project_management_request(self):
        """Testa solicita√ß√£o de gest√£o de projeto (PM focus)"""
        print("\n" + "="*60)
        print("üìä TESTE 5: Solicita√ß√£o de Gest√£o de Projeto")
        print("="*60)
        
        request = """
        Preciso planejar um projeto de desenvolvimento de software com:
        - Equipe de 8 pessoas
        - Prazo de 6 meses
        - Or√ßamento limitado
        - Metodologia √°gil
        - Entregas incrementais
        - Gest√£o de riscos
        
        Como organizar e executar este projeto com sucesso?
        """
        
        start_time = time.time()
        try:
            response = await self.orchestrator.process_request(request.strip())
            end_time = time.time()
            
            # Valida√ß√µes
            assert response is not None, "Resposta n√£o pode ser None"
            assert len(response) > 150, "Resposta muito curta"
            assert any(word in response.lower() for word in ["projeto", "agile", "scrum", "planejamento", "gest√£o"]), "Deve mencionar aspectos de gest√£o"
            
            print(f"‚úÖ Teste gest√£o de projeto passou!")
            print(f"‚è±Ô∏è Tempo de resposta: {end_time - start_time:.2f}s")
            print(f"üìù Tamanho da resposta: {len(response)} caracteres")
            
            self.test_results.append({
                "test": "Project Management Request",
                "status": "PASS",
                "time": end_time - start_time,
                "response_length": len(response)
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Teste gest√£o de projeto falhou: {e}")
            self.test_results.append({
                "test": "Project Management Request",
                "status": "FAIL",
                "error": str(e)
            })
            return False
    
    async def test_iteration_functionality(self):
        """Testa funcionalidade de itera√ß√£o"""
        print("\n" + "="*60)
        print("üîÑ TESTE 6: Funcionalidade de Itera√ß√£o")
        print("="*60)
        
        # Primeira solicita√ß√£o
        initial_request = "Quero criar um site simples para minha empresa."
        
        try:
            print("üìù Processando solicita√ß√£o inicial...")
            initial_response = await self.orchestrator.process_request(initial_request)
            
            # Obter sess√£o ativa
            sessions = list(self.orchestrator.active_sessions.keys())
            assert len(sessions) > 0, "Deve ter pelo menos uma sess√£o ativa"
            
            session_id = sessions[0]
            print(f"üîç Sess√£o ativa: {session_id}")
            
            # Feedback para itera√ß√£o
            feedback = """
            Gostei da proposta inicial, mas preciso de mais detalhes sobre:
            - Tecnologias espec√≠ficas a usar
            - Cronograma de desenvolvimento
            - Or√ßamento estimado
            - Funcionalidades priorit√°rias
            """
            
            print("üîÑ Processando itera√ß√£o com feedback...")
            start_time = time.time()
            refined_response = await self.orchestrator.iterate_solution(session_id, feedback)
            end_time = time.time()
            
            # Valida√ß√µes
            assert refined_response is not None, "Resposta refinada n√£o pode ser None"
            assert len(refined_response) > 100, "Resposta refinada muito curta"
            assert refined_response != initial_response, "Resposta refinada deve ser diferente da inicial"
            
            # Verificar se itera√ß√£o foi registrada
            session_status = self.orchestrator.get_session_status(session_id)
            assert session_status["iterations"] > 0, "Deve ter pelo menos uma itera√ß√£o"
            
            print(f"‚úÖ Teste de itera√ß√£o passou!")
            print(f"‚è±Ô∏è Tempo de itera√ß√£o: {end_time - start_time:.2f}s")
            print(f"üî¢ Itera√ß√µes registradas: {session_status['iterations']}")
            
            self.test_results.append({
                "test": "Iteration Functionality",
                "status": "PASS",
                "time": end_time - start_time,
                "iterations": session_status["iterations"]
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Teste de itera√ß√£o falhou: {e}")
            self.test_results.append({
                "test": "Iteration Functionality",
                "status": "FAIL",
                "error": str(e)
            })
            return False
    
    async def test_collaboration_metrics(self):
        """Testa m√©tricas de colabora√ß√£o"""
        print("\n" + "="*60)
        print("üìä TESTE 7: M√©tricas de Colabora√ß√£o")
        print("="*60)
        
        try:
            # Obter estat√≠sticas de colabora√ß√£o
            stats = self.orchestrator.collaboration_framework.get_collaboration_stats()
            
            print(f"üìà Estat√≠sticas de colabora√ß√£o:")
            print(f"   Total de colabora√ß√µes: {stats.get('total_collaborations', 0)}")
            print(f"   Agentes participantes: {len(stats.get('agent_stats', {}))}")
            
            # Valida√ß√µes b√°sicas
            assert isinstance(stats, dict), "Estat√≠sticas devem ser um dicion√°rio"
            assert "total_collaborations" in stats, "Deve ter total de colabora√ß√µes"
            
            print(f"‚úÖ Teste de m√©tricas passou!")
            
            self.test_results.append({
                "test": "Collaboration Metrics",
                "status": "PASS",
                "total_collaborations": stats.get('total_collaborations', 0)
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Teste de m√©tricas falhou: {e}")
            self.test_results.append({
                "test": "Collaboration Metrics",
                "status": "FAIL",
                "error": str(e)
            })
            return False
    
    async def test_agent_individual_functionality(self):
        """Testa funcionalidade individual dos agentes"""
        print("\n" + "="*60)
        print("üë• TESTE 8: Funcionalidade Individual dos Agentes")
        print("="*60)
        
        try:
            agents = self.orchestrator.get_active_agents()
            print(f"üîç Testando {len(agents)} agentes...")
            
            for agent_id in agents[:3]:  # Testar apenas 3 agentes para economizar tempo
                agent = self.orchestrator.agents[agent_id]
                
                # Testar an√°lise individual
                test_request = "Desenvolver uma funcionalidade de login"
                analysis = await agent.analyze_request(test_request)
                
                assert analysis is not None, f"An√°lise do {agent_id} n√£o pode ser None"
                assert len(analysis) > 50, f"An√°lise do {agent_id} muito curta"
                
                # Testar informa√ß√µes do agente
                agent_info = agent.get_agent_info()
                assert "profile" in agent_info, f"Info do {agent_id} deve ter profile"
                assert "status" in agent_info, f"Info do {agent_id} deve ter status"
                
                print(f"   ‚úÖ {agent.profile.name} - OK")
            
            print(f"‚úÖ Teste de agentes individuais passou!")
            
            self.test_results.append({
                "test": "Individual Agent Functionality",
                "status": "PASS",
                "agents_tested": len(agents)
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Teste de agentes individuais falhou: {e}")
            self.test_results.append({
                "test": "Individual Agent Functionality",
                "status": "FAIL",
                "error": str(e)
            })
            return False
    
    async def cleanup_system(self):
        """Limpa o sistema ap√≥s os testes"""
        try:
            if self.orchestrator:
                await self.orchestrator.shutdown()
                print("üßπ Sistema limpo com sucesso!")
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na limpeza: {e}")
            return False
    
    def print_final_report(self):
        """Imprime relat√≥rio final dos testes"""
        print("\n" + "="*80)
        print("üìã RELAT√ìRIO FINAL DE VALIDA√á√ÉO")
        print("="*80)
        
        total_tests = len(self.test_results)
        passed_tests = len([r for r in self.test_results if r["status"] == "PASS"])
        failed_tests = total_tests - passed_tests
        
        print(f"üìä Resumo dos Testes:")
        print(f"   Total: {total_tests}")
        print(f"   ‚úÖ Passou: {passed_tests}")
        print(f"   ‚ùå Falhou: {failed_tests}")
        print(f"   üìà Taxa de Sucesso: {(passed_tests/total_tests)*100:.1f}%")
        
        if failed_tests == 0:
            print("\nüéâ TODOS OS TESTES PASSARAM!")
            print("‚úÖ Sistema CWB Hub Hybrid AI est√° 100% funcional!")
        else:
            print(f"\n‚ö†Ô∏è {failed_tests} teste(s) falharam:")
            for result in self.test_results:
                if result["status"] == "FAIL":
                    print(f"   ‚ùå {result['test']}: {result.get('error', 'Erro desconhecido')}")
        
        # M√©tricas de performance
        times = [r.get("time", 0) for r in self.test_results if "time" in r]
        if times:
            avg_time = sum(times) / len(times)
            print(f"\n‚è±Ô∏è Performance:")
            print(f"   Tempo m√©dio de resposta: {avg_time:.2f}s")
            print(f"   Tempo total de testes: {sum(times):.2f}s")
        
        return failed_tests == 0

async def main():
    """Fun√ß√£o principal de valida√ß√£o"""
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                    CWB HUB HYBRID AI                         ‚ïë
    ‚ïë                  VALIDA√á√ÉO COMPLETA                          ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  Testando todas as funcionalidades do sistema               ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    validator = SystemValidator()
    
    try:
        # Inicializar sistema
        if not await validator.initialize_system():
            print("‚ùå Falha na inicializa√ß√£o. Abortando testes.")
            return False
        
        # Executar todos os testes
        tests = [
            validator.test_strategic_request,
            validator.test_technical_request,
            validator.test_mobile_design_request,
            validator.test_devops_quality_request,
            validator.test_project_management_request,
            validator.test_iteration_functionality,
            validator.test_collaboration_metrics,
            validator.test_agent_individual_functionality
        ]
        
        print(f"\nüöÄ Executando {len(tests)} testes de valida√ß√£o...")
        
        for i, test in enumerate(tests, 1):
            print(f"\nüìã Progresso: {i}/{len(tests)}")
            await test()
            
            # Pequena pausa entre testes
            await asyncio.sleep(0.5)
        
        # Relat√≥rio final
        success = validator.print_final_report()
        
        return success
        
    except Exception as e:
        print(f"‚ùå Erro cr√≠tico durante valida√ß√£o: {e}")
        return False
        
    finally:
        # Sempre limpar o sistema
        await validator.cleanup_system()

if __name__ == "__main__":
    try:
        success = asyncio.run(main())
        if success:
            print("\nüéâ VALIDA√á√ÉO COMPLETA: Sistema aprovado!")
            exit(0)
        else:
            print("\n‚ùå VALIDA√á√ÉO FALHOU: Verificar erros acima.")
            exit(1)
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Valida√ß√£o interrompida pelo usu√°rio.")
        exit(1)
    except Exception as e:
        print(f"\nüí• Erro fatal na valida√ß√£o: {e}")
        exit(1)